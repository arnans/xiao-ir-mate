substitutions:
  name: "seeed-ir"
  friendly_name: "Panasonic AC Controller"
  version: "v1"

esphome:
  name: xiao-ir-ac-controller
  friendly_name: Xiao-IR-AC-Controller

esp32:
  board: seeed_xiao_esp32c3   # Use seeed_xiao_esp32c3 if your board is the Seeed XIAO C3
  framework:
    type: arduino

external_components:
  - source:
      type: git
      url: https://github.com/mistic100/ESPHome-IRremoteESP8266
    components: [ ir_remote_base, panasonic ]

globals:
  - id: is_wifi_connected
    type: bool
    initial_value: 'false'
  - id: reset_press_time
    type: uint32_t
    initial_value: '0'
  - id: touch_count
    type: int
    restore_value: no
    initial_value: '0'
  - id: touch_timer
    type: unsigned long
    restore_value: no
    initial_value: '0'

logger:
  level: INFO

api:
  encryption:
    key: "U/lyvWTpxGBxJstAPb2MZ0oY4I8azHqD4S8XmZFBKsU="

ota:
  - platform: esphome
    password: "574f7f59310160a8efde98f3b2984b3d"

wifi:
  ssid: "Harbour Point"
  password: "chiangmai"
  on_connect:
    - globals.set: {id: is_wifi_connected, value: 'true'}
    - light.turn_on: rgb_light
  on_disconnect:
    - globals.set: {id: is_wifi_connected, value: 'false'}
  ap:
    password: "12345678"

captive_portal:

remote_transmitter:
  id: default_ir_transmitter
  pin: GPIO3
  carrier_duty_percent: 50%

remote_receiver:
  id: default_ir_receiver
  pin:
    number: GPIO4
    inverted: true
  dump: raw

climate:
  - platform: panasonic
    name: "Panasonic Air Conditioner"
    id: panasonic_ac
    model: DKE                  # <-- change if your Panasonic model differs
    transmitter_id: default_ir_transmitter
    supports_cool: true
    supports_heat: false        # set true if your unit supports heat

binary_sensor:
  - platform: gpio
    id: touch_pad
    pin:
      number: GPIO5
      mode: INPUT_PULLDOWN
    on_state:
      then:
        - if:
            condition:
              binary_sensor.is_on: touch_pad
            then:
              - script.execute: vibe_short
              - lambda: |-
                  unsigned long current_time = millis();
                  if (current_time - id(touch_timer) < 300) {
                    id(touch_count)++;
                  } else {
                    id(touch_count) = 1;
                  }
                  id(touch_timer) = current_time;
                  ESP_LOGD("touch_pad", "Touch detected. Current count: %d", id(touch_count));
                  if (id(check_touch_actions_script).is_running()) {
                    id(check_touch_actions_script).stop();
                  }
                  id(check_touch_actions_script).execute();

  - platform: gpio
    id: reset_button
    pin:
      number: GPIO9
      mode: INPUT_PULLUP
    filters:
      - invert
    on_press:
      then:
        - lambda: id(reset_press_time) = millis();
    on_release:
      then:
        - lambda: |-
            uint32_t press_duration = millis() - id(reset_press_time);
            if (press_duration < 5000) {
              id(vibe_short).execute();
              ESP_LOGI("reset_button", "Short press: Restarting device.");
              ESP.restart();
            } else {
              id(vibe_long).execute();
              ESP_LOGI("reset_button", "Long press: Activating factory reset.");
              id(factory_reset_switch).turn_on();
            }

output:
  - platform: gpio
    id: vibration_output
    pin: GPIO6

switch:
  - platform: output
    id: vibration_switch
    name: "Vibration Motor"
    output: vibration_output
  - platform: factory_reset
    id: factory_reset_switch
    name: "Factory Reset"

light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO7
    num_leds: 1
    chipset: ws2812
    name: "RGB Status Light"
    id: rgb_light
    default_transition_length: 0s
    on_turn_on:
      - light.control:
          id: rgb_light
          red: 1.0
          green: 1.0
          blue: 1.0
          brightness: 0.7
    effects:
      - addressable_scan:
      - addressable_rainbow:

script:
  - id: vibe_short
    then:
      - switch.turn_on: vibration_switch
      - delay: 100ms
      - switch.turn_off: vibration_switch

  - id: vibe_long
    then:
      - switch.turn_on: vibration_switch
      - delay: 500ms
      - switch.turn_off: vibration_switch

  - id: check_touch_actions_script
    mode: restart
    then:
      - delay: 350ms
      - if:
          condition:
            lambda: 'return id(touch_count) == 1;'
          then:
            - logger.log: "Single Click: Toggling Panasonic AC Power"
            - lambda: |-
                if (id(panasonic_ac).mode == climate::CLIMATE_MODE_OFF) {
                  auto call = id(panasonic_ac).make_call();
                  call.set_mode(climate::CLIMATE_MODE_COOL);
                  call.set_target_temperature(25);
                  call.perform();
                } else {
                  auto call = id(panasonic_ac).make_call();
                  call.set_mode(climate::CLIMATE_MODE_OFF);
                  call.perform();
                }
          else:
            - if:
                condition:
                  lambda: 'return id(touch_count) == 2;'
                then:
                  - logger.log: "Double Click: Panasonic AC Temperature Up"
                  - lambda: |-
                      if (id(panasonic_ac).mode != climate::CLIMATE_MODE_OFF) {
                        float t = id(panasonic_ac).target_temperature;
                        float max_t = id(panasonic_ac).get_traits().get_visual_max_temperature();
                        if (t < max_t) {
                          auto call = id(panasonic_ac).make_call();
                          call.set_target_temperature(t + 1.0f);
                          call.perform();
                        }
                      }
                else:
                  - if:
                      condition:
                        lambda: 'return id(touch_count) == 3;'
                      then:
                        - logger.log: "Triple Click: Panasonic AC Temperature Down"
                        - lambda: |-
                            if (id(panasonic_ac).mode != climate::CLIMATE_MODE_OFF) {
                              float t = id(panasonic_ac).target_temperature;
                              float min_t = id(panasonic_ac).get_traits().get_visual_min_temperature();
                              if (t > min_t) {
                                auto call = id(panasonic_ac).make_call();
                                call.set_target_temperature(t - 1.0f);
                                call.perform();
                              }
                            }
                      else:
                        - logger.log:
                            level: WARN
                            format: "Touch Action: No specific action defined for %d clicks."
                            args: ['id(touch_count)']
      - lambda: 'id(touch_count) = 0;'

interval:
  - id: blink_rgb_interval
    interval: 500ms
    then:
      - if:
          condition:
            lambda: 'return !id(is_wifi_connected);'
          then:
            - lambda: |-
                static bool s = false;
                s = !s;
                auto call = id(rgb_light).turn_on();
                if (s) {
                  call.set_rgb(0, 0, 1);
                  call.set_brightness(0.5);
                } else {
                  call.set_rgb(0, 0, 0);
                }
                call.perform();
